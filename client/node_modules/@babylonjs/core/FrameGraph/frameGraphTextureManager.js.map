{"version":3,"file":"frameGraphTextureManager.js","sourceRoot":"","sources":["../../../../dev/core/src/FrameGraph/frameGraphTextureManager.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\r\n    Scene,\r\n    AbstractEngine,\r\n    TextureSize,\r\n    Nullable,\r\n    FrameGraphTextureCreationOptions,\r\n    FrameGraphTextureHandle,\r\n    InternalTextureCreationOptions,\r\n    InternalTexture,\r\n    FrameGraphTextureOptions,\r\n    FrameGraphTextureDescription,\r\n    RenderTargetWrapper,\r\n    // eslint-disable-next-line import/no-internal-modules\r\n} from \"core/index\";\r\nimport { getDimensionsFromTextureSize, textureSizeIsObject } from \"../Materials/Textures/textureCreationOptions\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { backbufferColorTextureHandle, backbufferDepthStencilTextureHandle } from \"./frameGraphTypes\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { InternalTextureSource, GetTypeForDepthTexture, IsDepthTexture, HasStencilAspect } from \"../Materials/Textures/internalTexture\";\r\nimport { FrameGraphRenderTarget } from \"./frameGraphRenderTarget\";\r\n\r\ntype HistoryTexture = {\r\n    textures: Array<Nullable<InternalTexture>>;\r\n    handles: Array<FrameGraphTextureHandle>;\r\n    index: number; // current index in textures array\r\n    references: Array<{ renderTargetWrapper: RenderTargetWrapper; textureIndex: number }>; // render target wrappers that reference this history texture\r\n};\r\n\r\ntype TextureEntry = {\r\n    texture: Nullable<InternalTexture>;\r\n    name: string;\r\n    creationOptions: FrameGraphTextureCreationOptions; // in TextureEntry, creationOptions.size is always an object\r\n    namespace: FrameGraphTextureNamespace;\r\n    textureIndex?: number; // Index of the texture in the types, formats, etc array of FrameGraphTextureOptions (default: 0)\r\n    debug?: Texture;\r\n    refHandle?: FrameGraphTextureHandle; // Handle of the texture this one is referencing - used for dangling handles\r\n};\r\n\r\nenum FrameGraphTextureNamespace {\r\n    Task,\r\n    Graph,\r\n    External,\r\n}\r\n\r\n/**\r\n * Manages the textures used by a frame graph\r\n * @experimental\r\n */\r\nexport class FrameGraphTextureManager {\r\n    private static _Counter = 2; // 0 and 1 are reserved for backbuffer textures\r\n\r\n    /** @internal */\r\n    public readonly _textures: Map<FrameGraphTextureHandle, TextureEntry> = new Map();\r\n\r\n    /** @internal */\r\n    public readonly _historyTextures: Map<FrameGraphTextureHandle, HistoryTexture> = new Map();\r\n\r\n    /** @internal */\r\n    public _isRecordingTask = false;\r\n\r\n    /**\r\n     * Constructs a new instance of the texture manager\r\n     * @param engine The engine to use\r\n     * @param _debugTextures If true, debug textures will be created so that they are visible in the inspector\r\n     * @param _scene The scene the manager belongs to\r\n     */\r\n    constructor(\r\n        public readonly engine: AbstractEngine,\r\n        private readonly _debugTextures = false,\r\n        private readonly _scene: Scene\r\n    ) {\r\n        this._addSystemTextures();\r\n    }\r\n\r\n    /**\r\n     * Checks if a handle is a backbuffer handle (color or depth/stencil)\r\n     * @param handle The handle to check\r\n     * @returns True if the handle is a backbuffer handle\r\n     */\r\n    public isBackbuffer(handle: FrameGraphTextureHandle): boolean {\r\n        if (handle === backbufferColorTextureHandle || handle === backbufferDepthStencilTextureHandle) {\r\n            return true;\r\n        }\r\n\r\n        const textureEntry = this._textures.get(handle);\r\n        if (!textureEntry) {\r\n            return false;\r\n        }\r\n\r\n        return textureEntry.refHandle === backbufferColorTextureHandle || textureEntry.refHandle === backbufferDepthStencilTextureHandle;\r\n    }\r\n\r\n    /**\r\n     * Checks if a handle is a backbuffer color handle\r\n     * @param handle The handle to check\r\n     * @returns True if the handle is a backbuffer color handle\r\n     */\r\n    public isBackbufferColor(handle: FrameGraphTextureHandle): boolean {\r\n        if (handle === backbufferColorTextureHandle) {\r\n            return true;\r\n        }\r\n\r\n        const textureEntry = this._textures.get(handle);\r\n        if (!textureEntry) {\r\n            return false;\r\n        }\r\n\r\n        return textureEntry.refHandle === backbufferColorTextureHandle;\r\n    }\r\n\r\n    /**\r\n     * Checks if a handle is a backbuffer depth/stencil handle\r\n     * @param handle The handle to check\r\n     * @returns True if the handle is a backbuffer depth/stencil handle\r\n     */\r\n    public isBackbufferDepthStencil(handle: FrameGraphTextureHandle): boolean {\r\n        if (handle === backbufferDepthStencilTextureHandle) {\r\n            return true;\r\n        }\r\n\r\n        const textureEntry = this._textures.get(handle);\r\n        if (!textureEntry) {\r\n            return false;\r\n        }\r\n\r\n        return textureEntry.refHandle === backbufferDepthStencilTextureHandle;\r\n    }\r\n\r\n    /**\r\n     * Checks if a handle is a history texture (or points to a history texture, for a dangling handle)\r\n     * @param handle The handle to check\r\n     * @returns True if the handle is a history texture, otherwise false\r\n     */\r\n    public isHistoryTexture(handle: FrameGraphTextureHandle): boolean {\r\n        const entry = this._textures.get(handle);\r\n        if (!entry) {\r\n            return false;\r\n        }\r\n\r\n        handle = entry.refHandle ?? handle;\r\n\r\n        return this._historyTextures.has(handle);\r\n    }\r\n\r\n    /**\r\n     * Gets the creation options of a texture\r\n     * @param handle Handle of the texture\r\n     * @returns The creation options of the texture\r\n     */\r\n    public getTextureCreationOptions(handle: FrameGraphTextureHandle): FrameGraphTextureCreationOptions {\r\n        const entry = this._textures.get(handle)!;\r\n        const creationOptions = entry.creationOptions;\r\n\r\n        return {\r\n            size: textureSizeIsObject(creationOptions.size) ? { ...creationOptions.size } : creationOptions.size,\r\n            sizeIsPercentage: creationOptions.sizeIsPercentage,\r\n            options: FrameGraphTextureManager.CloneTextureOptions(creationOptions.options, entry.textureIndex),\r\n            isHistoryTexture: creationOptions.isHistoryTexture,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the description of a texture\r\n     * @param handle Handle of the texture\r\n     * @returns The description of the texture\r\n     */\r\n    public getTextureDescription(handle: FrameGraphTextureHandle): FrameGraphTextureDescription {\r\n        const creationOptions = this.getTextureCreationOptions(handle);\r\n\r\n        const size = !creationOptions.sizeIsPercentage\r\n            ? textureSizeIsObject(creationOptions.size)\r\n                ? creationOptions.size\r\n                : { width: creationOptions.size, height: creationOptions.size }\r\n            : this.getAbsoluteDimensions(creationOptions.size);\r\n\r\n        return {\r\n            size,\r\n            options: creationOptions.options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets a texture handle or creates a new texture if the handle is not provided.\r\n     * If handle is not provided, newTextureName and creationOptions must be provided.\r\n     * @param handle If provided, will simply return the handle\r\n     * @param newTextureName Name of the new texture to create\r\n     * @param creationOptions Options to use when creating the new texture\r\n     * @returns The handle to the texture.\r\n     */\r\n    public getTextureHandleOrCreateTexture(handle?: FrameGraphTextureHandle, newTextureName?: string, creationOptions?: FrameGraphTextureCreationOptions): FrameGraphTextureHandle {\r\n        if (handle === undefined) {\r\n            if (newTextureName === undefined || creationOptions === undefined) {\r\n                throw new Error(\"getTextureHandleOrCreateTexture: Either handle or newTextureName and creationOptions must be provided.\");\r\n            }\r\n            return this.createRenderTargetTexture(newTextureName, creationOptions);\r\n        }\r\n        return handle;\r\n    }\r\n\r\n    /**\r\n     * Gets a texture from a handle.\r\n     * Note that if the texture is a history texture, the read texture for the current frame will be returned.\r\n     * @param handle The handle of the texture\r\n     * @returns The texture or null if not found\r\n     */\r\n    public getTextureFromHandle(handle: FrameGraphTextureHandle): Nullable<InternalTexture> {\r\n        const historyEntry = this._historyTextures.get(handle);\r\n        if (historyEntry) {\r\n            return historyEntry.textures[historyEntry.index ^ 1]; // gets the read texture\r\n        }\r\n        return this._textures.get(handle)!.texture;\r\n    }\r\n\r\n    /**\r\n     * Imports a texture into the texture manager\r\n     * @param name Name of the texture\r\n     * @param texture Texture to import\r\n     * @param handle Existing handle to use for the texture. If not provided (default), a new handle will be created.\r\n     * @returns The handle to the texture\r\n     */\r\n    public importTexture(name: string, texture: InternalTexture, handle?: FrameGraphTextureHandle): FrameGraphTextureHandle {\r\n        if (handle !== undefined) {\r\n            this._freeEntry(handle);\r\n        }\r\n\r\n        const creationOptions: FrameGraphTextureCreationOptions = {\r\n            size: { width: texture.width, height: texture.height },\r\n            sizeIsPercentage: false,\r\n            isHistoryTexture: false,\r\n            options: {\r\n                createMipMaps: texture.generateMipMaps,\r\n                samples: texture.samples,\r\n                types: [texture.type],\r\n                formats: [texture.format],\r\n                useSRGBBuffers: [texture._useSRGBBuffer],\r\n                creationFlags: [texture._creationFlags],\r\n                labels: texture.label ? [texture.label] : [\"imported\"],\r\n            },\r\n        };\r\n\r\n        return this._createHandleForTexture(name, texture, creationOptions, FrameGraphTextureNamespace.External, handle);\r\n    }\r\n\r\n    /**\r\n     * Creates a new render target texture\r\n     * If multiple textures are described in FrameGraphTextureCreationOptions, the handle of the first texture is returned, handle+1 is the handle of the second texture, etc.\r\n     * @param name Name of the texture\r\n     * @param creationOptions Options to use when creating the texture\r\n     * @param handle Existing handle to use for the texture. If not provided (default), a new handle will be created.\r\n     * @returns The handle to the texture\r\n     */\r\n    public createRenderTargetTexture(name: string, creationOptions: FrameGraphTextureCreationOptions, handle?: FrameGraphTextureHandle): FrameGraphTextureHandle {\r\n        return this._createHandleForTexture(\r\n            name,\r\n            null,\r\n            {\r\n                size: textureSizeIsObject(creationOptions.size) ? { ...creationOptions.size } : creationOptions.size,\r\n                sizeIsPercentage: creationOptions.sizeIsPercentage,\r\n                isHistoryTexture: creationOptions.isHistoryTexture,\r\n                options: FrameGraphTextureManager.CloneTextureOptions(creationOptions.options),\r\n            },\r\n            this._isRecordingTask ? FrameGraphTextureNamespace.Task : FrameGraphTextureNamespace.Graph,\r\n            handle\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a (frame graph) render target wrapper\r\n     * Note that renderTargets or renderTargetDepth can be undefined, but not both at the same time!\r\n     * @param name Name of the render target wrapper\r\n     * @param renderTargets Render target handles (textures) to use\r\n     * @param renderTargetDepth Render target depth handle (texture) to use\r\n     * @returns The created render target wrapper\r\n     */\r\n    public createRenderTarget(\r\n        name: string,\r\n        renderTargets?: FrameGraphTextureHandle | FrameGraphTextureHandle[],\r\n        renderTargetDepth?: FrameGraphTextureHandle\r\n    ): FrameGraphRenderTarget {\r\n        const renderTarget = new FrameGraphRenderTarget(name, this, renderTargets, renderTargetDepth);\r\n\r\n        const rtw = renderTarget.renderTargetWrapper;\r\n\r\n        if (rtw !== undefined && renderTargets) {\r\n            const handles = Array.isArray(renderTargets) ? renderTargets : [renderTargets];\r\n\r\n            for (let i = 0; i < handles.length; i++) {\r\n                let handle = handles[i];\r\n                handle = this._textures.get(handle)?.refHandle ?? handle;\r\n\r\n                const historyEntry = this._historyTextures.get(handle);\r\n                if (historyEntry) {\r\n                    historyEntry.references.push({ renderTargetWrapper: rtw, textureIndex: i });\r\n\r\n                    rtw.setTexture(historyEntry.textures[historyEntry.index]!, i, false);\r\n                }\r\n            }\r\n        }\r\n\r\n        return renderTarget;\r\n    }\r\n\r\n    /**\r\n     * Creates a handle which is not associated with any texture.\r\n     * Call resolveDanglingHandle to associate the handle with a valid texture handle.\r\n     * @returns The dangling handle\r\n     */\r\n    public createDanglingHandle() {\r\n        return FrameGraphTextureManager._Counter++;\r\n    }\r\n\r\n    /**\r\n     * Associates a texture with a dangling handle\r\n     * @param danglingHandle The dangling handle\r\n     * @param handle The handle to associate with the dangling handle (if not provided, a new texture handle will be created, using the newTextureName and creationOptions parameters)\r\n     * @param newTextureName The name of the new texture to create (if handle is not provided)\r\n     * @param creationOptions The options to use when creating the new texture (if handle is not provided)\r\n     */\r\n    public resolveDanglingHandle(\r\n        danglingHandle: FrameGraphTextureHandle,\r\n        handle?: FrameGraphTextureHandle,\r\n        newTextureName?: string,\r\n        creationOptions?: FrameGraphTextureCreationOptions\r\n    ) {\r\n        if (handle === undefined) {\r\n            if (newTextureName === undefined || creationOptions === undefined) {\r\n                throw new Error(\"resolveDanglingHandle: Either handle or newTextureName and creationOptions must be provided.\");\r\n            }\r\n            this.createRenderTargetTexture(newTextureName, creationOptions, danglingHandle);\r\n            return;\r\n        }\r\n\r\n        const textureEntry = this._textures.get(handle);\r\n\r\n        if (textureEntry === undefined) {\r\n            throw new Error(`resolveDanglingHandle: Handle ${handle} does not exist!`);\r\n        }\r\n\r\n        this._textures.set(danglingHandle, {\r\n            texture: textureEntry.texture,\r\n            refHandle: handle,\r\n            name: textureEntry.name,\r\n            creationOptions: {\r\n                size: { ...(textureEntry.creationOptions.size as { width: number; height: number; depth?: number; layers?: number }) },\r\n                options: FrameGraphTextureManager.CloneTextureOptions(textureEntry.creationOptions.options),\r\n                sizeIsPercentage: textureEntry.creationOptions.sizeIsPercentage,\r\n                isHistoryTexture: false,\r\n            },\r\n            namespace: textureEntry.namespace,\r\n            textureIndex: textureEntry.textureIndex,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the absolute dimensions of a texture.\r\n     * @param size The size of the texture. Width and height must be expressed as a percentage of the screen size (100=100%)!\r\n     * @param screenWidth The width of the screen (default: the width of the rendering canvas)\r\n     * @param screenHeight The height of the screen (default: the height of the rendering canvas)\r\n     * @returns The absolute dimensions of the texture\r\n     */\r\n    public getAbsoluteDimensions(\r\n        size: TextureSize,\r\n        screenWidth = this.engine.getRenderWidth(true),\r\n        screenHeight = this.engine.getRenderHeight(true)\r\n    ): { width: number; height: number } {\r\n        const { width, height } = getDimensionsFromTextureSize(size);\r\n\r\n        return {\r\n            width: Math.floor((width * screenWidth) / 100),\r\n            height: Math.floor((height * screenHeight) / 100),\r\n        };\r\n    }\r\n\r\n    /** @internal */\r\n    public _dispose(): void {\r\n        this._releaseTextures();\r\n    }\r\n\r\n    /** @internal */\r\n    public _allocateTextures() {\r\n        this._textures.forEach((entry) => {\r\n            if (!entry.texture) {\r\n                if (entry.refHandle !== undefined) {\r\n                    // entry is a dangling handle which has been resolved to point to refHandle\r\n                    // We simply update the texture to point to the refHandle texture\r\n                    const refEntry = this._textures.get(entry.refHandle)!;\r\n\r\n                    entry.texture = refEntry.texture;\r\n\r\n                    if (refEntry.refHandle === backbufferColorTextureHandle) {\r\n                        entry.refHandle = backbufferColorTextureHandle;\r\n                    }\r\n                    if (refEntry.refHandle === backbufferDepthStencilTextureHandle) {\r\n                        entry.refHandle = backbufferDepthStencilTextureHandle;\r\n                    }\r\n                } else if (entry.namespace !== FrameGraphTextureNamespace.External) {\r\n                    const creationOptions = entry.creationOptions;\r\n                    const size = creationOptions.sizeIsPercentage ? this.getAbsoluteDimensions(creationOptions.size) : creationOptions.size;\r\n                    const textureIndex = entry.textureIndex || 0;\r\n\r\n                    const internalTextureCreationOptions: InternalTextureCreationOptions = {\r\n                        createMipMaps: creationOptions.options.createMipMaps,\r\n                        samples: creationOptions.options.samples,\r\n                        type: creationOptions.options.types?.[textureIndex],\r\n                        format: creationOptions.options.formats?.[textureIndex],\r\n                        useSRGBBuffer: creationOptions.options.useSRGBBuffers?.[textureIndex],\r\n                        creationFlags: creationOptions.options.creationFlags?.[textureIndex],\r\n                        label: creationOptions.options.labels?.[textureIndex] ?? `${entry.name}${textureIndex > 0 ? \"#\" + textureIndex : \"\"}`,\r\n                        samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                        createMSAATexture: creationOptions.options.samples! > 1,\r\n                    };\r\n\r\n                    const isDepthTexture = IsDepthTexture(internalTextureCreationOptions.format!);\r\n                    const hasStencil = HasStencilAspect(internalTextureCreationOptions.format!);\r\n                    const source =\r\n                        isDepthTexture && hasStencil\r\n                            ? InternalTextureSource.DepthStencil\r\n                            : isDepthTexture || hasStencil\r\n                              ? InternalTextureSource.Depth\r\n                              : InternalTextureSource.RenderTarget;\r\n\r\n                    const internalTexture = this.engine._createInternalTexture(size, internalTextureCreationOptions, false, source);\r\n\r\n                    if (isDepthTexture) {\r\n                        internalTexture.type = GetTypeForDepthTexture(internalTexture.format);\r\n                    }\r\n\r\n                    entry.texture = internalTexture;\r\n                }\r\n            }\r\n\r\n            if (entry.texture && entry.refHandle === undefined) {\r\n                entry.debug?.dispose();\r\n                entry.debug = this._createDebugTexture(entry.name, entry.texture);\r\n            }\r\n        });\r\n\r\n        this._historyTextures.forEach((entry) => {\r\n            for (let i = 0; i < entry.handles.length; i++) {\r\n                entry.textures[i] = this._textures.get(entry.handles[i])!.texture;\r\n            }\r\n        });\r\n    }\r\n\r\n    /** @internal */\r\n    public _releaseTextures(releaseAll = true): void {\r\n        this._textures.forEach((entry, handle) => {\r\n            if (releaseAll || entry.namespace !== FrameGraphTextureNamespace.External) {\r\n                entry.debug?.dispose();\r\n                entry.debug = undefined;\r\n            }\r\n\r\n            if (entry.namespace === FrameGraphTextureNamespace.External) {\r\n                return;\r\n            }\r\n\r\n            entry.texture?.dispose();\r\n            entry.texture = null;\r\n\r\n            if (releaseAll || entry.namespace === FrameGraphTextureNamespace.Task) {\r\n                this._textures.delete(handle);\r\n            }\r\n        });\r\n\r\n        this._historyTextures.forEach((entry) => {\r\n            for (let i = 0; i < entry.handles.length; i++) {\r\n                entry.textures[i] = null;\r\n            }\r\n        });\r\n\r\n        if (releaseAll) {\r\n            this._textures.clear();\r\n            this._historyTextures.clear();\r\n            this._addSystemTextures();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateHistoryTextures(): void {\r\n        this._historyTextures.forEach((entry) => {\r\n            entry.index = entry.index ^ 1;\r\n            const currentTexture = entry.textures[entry.index];\r\n            if (currentTexture) {\r\n                for (const { renderTargetWrapper, textureIndex } of entry.references) {\r\n                    renderTargetWrapper.setTexture(currentTexture, textureIndex, false);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _addSystemTextures() {\r\n        const size = { width: this.engine.getRenderWidth(true), height: this.engine.getRenderHeight(true) };\r\n\r\n        this._textures.set(backbufferColorTextureHandle, {\r\n            name: \"backbuffer color\",\r\n            texture: null,\r\n            creationOptions: {\r\n                size,\r\n                options: {\r\n                    createMipMaps: false,\r\n                    samples: this.engine.getCreationOptions().antialias ? 4 : 1,\r\n                    types: [Constants.TEXTURETYPE_UNSIGNED_BYTE], // todo? get from engine\r\n                    formats: [Constants.TEXTUREFORMAT_RGBA], // todo? get from engine\r\n                    useSRGBBuffers: [false],\r\n                    creationFlags: [0],\r\n                    labels: [\"backbuffer color\"],\r\n                },\r\n                sizeIsPercentage: false,\r\n            },\r\n            namespace: FrameGraphTextureNamespace.External,\r\n        });\r\n\r\n        this._textures.set(backbufferDepthStencilTextureHandle, {\r\n            name: \"backbuffer depth/stencil\",\r\n            texture: null,\r\n            creationOptions: {\r\n                size,\r\n                options: {\r\n                    createMipMaps: false,\r\n                    samples: this.engine.getCreationOptions().antialias ? 4 : 1,\r\n                    types: [Constants.TEXTURETYPE_UNSIGNED_BYTE], // todo? get from engine\r\n                    formats: [Constants.TEXTUREFORMAT_DEPTH24], // todo? get from engine\r\n                    useSRGBBuffers: [false],\r\n                    creationFlags: [0],\r\n                    labels: [\"backbuffer depth/stencil\"],\r\n                },\r\n                sizeIsPercentage: false,\r\n            },\r\n            namespace: FrameGraphTextureNamespace.External,\r\n        });\r\n    }\r\n\r\n    private _createDebugTexture(name: string, texture: InternalTexture): Texture | undefined {\r\n        if (!this._debugTextures) {\r\n            return;\r\n        }\r\n\r\n        const textureDebug = new Texture(null, this._scene);\r\n\r\n        textureDebug.name = name;\r\n        textureDebug._texture = texture;\r\n        textureDebug._texture.incrementReferences();\r\n\r\n        return textureDebug;\r\n    }\r\n\r\n    private _freeEntry(handle: number): void {\r\n        const entry = this._textures.get(handle);\r\n\r\n        if (entry) {\r\n            entry.debug?.dispose();\r\n            this._textures.delete(handle);\r\n        }\r\n    }\r\n\r\n    private _createHandleForTexture(\r\n        name: string,\r\n        texture: Nullable<InternalTexture>,\r\n        creationOptions: FrameGraphTextureCreationOptions,\r\n        namespace: FrameGraphTextureNamespace,\r\n        handle?: FrameGraphTextureHandle,\r\n        textureIndex?: number\r\n    ): FrameGraphTextureHandle {\r\n        handle = handle ?? FrameGraphTextureManager._Counter++;\r\n        textureIndex = textureIndex || 0;\r\n\r\n        const textureName = creationOptions.isHistoryTexture ? `${name} ping` : name;\r\n\r\n        let label = creationOptions.options.labels?.[textureIndex] ?? \"\";\r\n        if (label === textureName) {\r\n            label = \"\";\r\n        }\r\n\r\n        const textureEntry: TextureEntry = {\r\n            texture,\r\n            name: `${textureName}${label ? \" \" + label : \"\"}`,\r\n            creationOptions: {\r\n                size: textureSizeIsObject(creationOptions.size) ? creationOptions.size : { width: creationOptions.size, height: creationOptions.size },\r\n                options: creationOptions.options,\r\n                sizeIsPercentage: creationOptions.sizeIsPercentage,\r\n                isHistoryTexture: creationOptions.isHistoryTexture,\r\n            },\r\n            namespace,\r\n            textureIndex,\r\n        };\r\n\r\n        this._textures.set(handle, textureEntry);\r\n\r\n        if (namespace === FrameGraphTextureNamespace.External) {\r\n            return handle;\r\n        }\r\n\r\n        if (creationOptions.isHistoryTexture) {\r\n            const pongCreationOptions: FrameGraphTextureCreationOptions = {\r\n                size: { ...(textureEntry.creationOptions.size as { width: number; height: number }) },\r\n                options: { ...textureEntry.creationOptions.options },\r\n                sizeIsPercentage: textureEntry.creationOptions.sizeIsPercentage,\r\n                isHistoryTexture: false,\r\n            };\r\n\r\n            const pongTexture = this._createHandleForTexture(`${name} pong`, null, pongCreationOptions, namespace);\r\n\r\n            this._historyTextures.set(handle, { textures: [null, null], handles: [handle, pongTexture], index: 0, references: [] });\r\n\r\n            return handle;\r\n        }\r\n\r\n        if (creationOptions.options.types && creationOptions.options.types.length > 1 && textureIndex === 0) {\r\n            const textureCount = creationOptions.options.types.length;\r\n            const creationOptionsForTexture: FrameGraphTextureCreationOptions = {\r\n                size: textureSizeIsObject(creationOptions.size) ? creationOptions.size : { width: creationOptions.size, height: creationOptions.size },\r\n                options: creationOptions.options,\r\n                sizeIsPercentage: creationOptions.sizeIsPercentage,\r\n            };\r\n\r\n            for (let i = 1; i < textureCount; i++) {\r\n                this._createHandleForTexture(textureName, null, creationOptionsForTexture, namespace, handle + i, i);\r\n            }\r\n\r\n            FrameGraphTextureManager._Counter += textureCount - 1;\r\n        }\r\n\r\n        return handle;\r\n    }\r\n\r\n    /**\r\n     * Clones a texture options\r\n     * @param options The options to clone\r\n     * @param textureIndex The index of the texture in the types, formats, etc array of FrameGraphTextureOptions. If not provided, all options are cloned.\r\n     * @returns The cloned options\r\n     */\r\n    public static CloneTextureOptions(options: FrameGraphTextureOptions, textureIndex?: number): FrameGraphTextureOptions {\r\n        return textureIndex !== undefined\r\n            ? {\r\n                  createMipMaps: options.createMipMaps,\r\n                  samples: options.samples,\r\n                  types: options.types ? [options.types[textureIndex]] : undefined,\r\n                  formats: options.formats ? [options.formats[textureIndex]] : undefined,\r\n                  useSRGBBuffers: options.useSRGBBuffers ? [options.useSRGBBuffers[textureIndex]] : undefined,\r\n                  creationFlags: options.creationFlags ? [options.creationFlags[textureIndex]] : undefined,\r\n                  labels: options.labels ? [options.labels[textureIndex]] : undefined,\r\n              }\r\n            : {\r\n                  createMipMaps: options.createMipMaps,\r\n                  samples: options.samples,\r\n                  types: options.types ? [...options.types] : undefined,\r\n                  formats: options.formats ? [...options.formats] : undefined,\r\n                  useSRGBBuffers: options.useSRGBBuffers ? [...options.useSRGBBuffers] : undefined,\r\n                  creationFlags: options.creationFlags ? [...options.creationFlags] : undefined,\r\n                  labels: options.labels ? [...options.labels] : undefined,\r\n              };\r\n    }\r\n}\r\n"]}